
#' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' ensembl_counts_to_rkpm
#' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' @title ensembl_counts_to_rkpm 
#' 
#' @description 
#' Converts an Ensemble counts matrix into RKPM. <rant> RKPM is a terrible way to 
#' look at your data.  Only do it if you have to. If you choose cDNA length in 
#' your calculation then you loose all the non-coding transcripts.  If you use 
#' the full transcript length then you should account for the number of full and 
#' cds sequences which there's no way to know...</rant>
#' 
#' @param file_prefix Output file will have this prefix string appended to it.
#' @param input_file_path String path to input file. File should have samples by row, first columns should be the sample id with all subsequent columns headers in the Ensembl ENST format (no version).
#' @param output_dir Path to the output folder.
#' @param this_script_path Path to script that runs this function for documentation purposes
#' @return A vector of paths to the output file.
#' 
#' @export
quantsf_to_matrix = function(
  conversion_table_path = get_human_ensembl_to_hgnc_entrez_path()
  file_prefix = "",
  input_file_path,
  output_dir,
  this_script_path = '',
  thread_num = 1
){
  library(binfotron)
  library(magrittr)
  library(data.table)
  library(matrixStats)
  
  dir.create(output_dir, showWarnings = F)
  
  if(file_prefix != ""){
    file_prefix %<>% paste0("__")
  } else if (grepl("__trans_counts.tsv$", basename(input_file_path))){
    file_prefix = gsub("trans_counts.tsv$", "", basename(input_file_path))
  }
  
  readme_path = file.path(output_dir, paste0(file_prefix,"readme.txt"))
  if(file.exists(readme_path)){ file.remove(readme_path)}
  
  a = function(...){
    my_output = paste0(...)
    if(!is.null(readme_path)){
      write(my_output, readme_path, append = TRUE)
    }
    cat(paste0(my_output,"\n"))
  }
  
  a("")
  
  # convert to a data table according to the names of the list 
  #   (ie, use.names = T won't assume the genes are in the same order)
  dat = fread(input_file_path)
  sample_key = names(dat)[1]
  
  conversion_df = fread(conversion_table_path, data.table = F, select = c("transcript_id","cdna_length"))
  
  a("Droping transcripts where cDNA length is NA")
  conversion_df = conversion_df[!is.na(conversion_df$cdna_length), ]
  conversion_df = conversion_df[conversion_df$cdna_length > 0, ]
  
  a("Calculating cdna_length/1000.")
  transcript_length_per_k_lut = conversion_df$cdna_length/1000
  names(transcript_length_per_k_lut) = conversion_df$transcript_id
  rm(conversion_df)
  
  dat = dat[,c(sample_key, names(transcript_length_per_k_lut)), with = F]
  
  # tried geting sample totals with data.frame operation but it was slower
  # sub_dat = dat[, 1:40000]
  # with 4 cores 40K columns ran in 19 sec instead of 26
  # with 24 cores all isoforms took 1130 sec
  # ptm <- proc.time()
  # sample_totals = dat[, parallel::mclapply(.SD, sum, na.rm=TRUE, mc.cores = thread_num), .SDcols=2:ncol(dat) ] 
  # proc.time() - ptm
  # use () around it to have data.table check the var name
  
  a("Calculating sample totals.")
  dat[, `:=`(total = rowSums(.SD, na.rm=T)), .SDcols=2:ncol(dat), by=1:nrow(dat)] # 56-60 sec

  total_lut = dat$total/1000000
  names(total_lut) = dat[[1]]
  dat[ , total := NULL]
  # > all(names(transcript_length_per_k_lut) == names(dat)[-1])
  # [1] TRUE
  # ptm <- proc.time()
  # for (c_index in 2:1000){ # 13 sec for 1000?!?
  #   dat[[c_index]] = dat[[c_index]]/transcript_length_per_k_lut[c_index]
  # }
  # proc.time() - ptm
  # mat %*% diag(1/dev),

  # https://stackoverflow.com/questions/20596433/how-to-divide-each-row-of-a-matrix-by-elements-of-a-vector-in-r
  mat = dat[,2:ncol(dat)] %>% as.matrix
  ptm <- proc.time()
  # mat = mat %*% diag(1/transcript_length_per_k_lut)
  a("Divide each gene column by its cdna_length/1000")
  mat = t(t(mat) / transcript_length_per_k_lut)
  
  a("Divide each sample row by its sample_total/1,000,000")
  mat = mat/total_lut
  
  proc.time() - ptm
  dat[,2:ncol(dat)] = data.frame(mat)
  

  
  output_path = file.path(output_dir, paste0(file_prefix, "trans_rkpm.tsv"))
  
  fwrite(dat, output_path, sep = "\t")

}
